// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum UserRole {
  ADMIN 
  USER
}

model User {
  id String @id @default(cuid())
  name String?
  email String? @unique
  username String? @unique
  emailVerified DateTime?
  image String?
  password String?
  role UserRole @default(USER)
  accounts Account[]
  isTwoFactorEnabled Boolean @default(false)
  twoFactorConfirmation TwoFactorConfirmation?
  transactions Transaction[] @relation("UserTransactions")
  sentTransactions Transaction[] @relation("SentTransactions")
  receivedTransactions Transaction[] @relation("ReceivedTransactions")
  receivedCryptoTransactions ReceivedTransaction[] @relation("ReceivedCryptoTransactions")
  usdt Float @default(0)
  btc Float @default(0)
  eth Float @default(0)
  referralCode String? @unique
  referredBy String?
  referrer User? @relation("UserReferrals", fields: [referredBy], references: [id])
  referrals User[] @relation("UserReferrals")
  referralRewards Referral[] @relation("ReferrerRewards")
  bankAccount UserBankAccount?

  @@index([referralCode])
}

model Account {
  id String @id @default(cuid())
  userId String
  type String
  provider String
  providerAccountId String
  refresh_token String? @db.Text
  access_token String? @db.Text
  expires_at Int?
  token_type String?
  scope String?
  id_token String? @db.Text
  session_state String?
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId]) 
}

model VerificationToken {
  id String @id @default(cuid())  
  email String
  token String @unique
  expires DateTime

  @@unique([email, token])
}

model PasswordResetToken {
  id String @id @default(cuid())
  email String
  token String @unique
  expires DateTime
  
  @@unique([email, token])  
}

model TwoFactorToken {
  id String @id @default(cuid())
  email String
  token String @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorConfirmation {
  id String @id @default(cuid())
  userId String
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])  
}

model Transaction {
  id             Int      @id @default(autoincrement())
  date           DateTime
  btc            Boolean  @default(false)
  usdt           Boolean  @default(false)
  eth            Boolean  @default(false)
  amount         Float
  walletAddress  String
  transactionId  String   @unique @default(cuid())
  userId         String
  recipientId    String?
  status         String   @default("pending")
  user           User     @relation("UserTransactions", fields: [userId], references: [id], map: "Transaction_userId_fkey")
  sender         User     @relation("SentTransactions", fields: [userId], references: [id], map: "Transaction_senderId_fkey")
  recipient      User?    @relation("ReceivedTransactions", fields: [recipientId], references: [id], map: "Transaction_recipientId_fkey")

  @@index([userId])
  @@index([recipientId])
}

model ReceivedTransaction {
  id             String   @id @default(cuid())
  date           DateTime @default(now())
  amount         Float
  cryptoType     String
  senderAddress  String
  recipientId    String
  senderUsername String
  status         String   @default("pending")
  transactionHash String  @unique
  recipient      User     @relation("ReceivedCryptoTransactions", fields: [recipientId], references: [id])
}

model BankAccount {
  id            String @id @default(cuid())
  bankName      String
  accountName   String
  accountNumber String
  status        String @default("active")
}

model Referral {
  id String @id @default(cuid())
  referrerId String
  referredUserId String
  rewardAmount Float
  createdAt DateTime @default(now())
  referrer User @relation("ReferrerRewards", fields: [referrerId], references: [id])

  @@unique([referrerId, referredUserId])
}

model UserBankAccount {
  id            String @id @default(cuid())
  userId        String @unique
  bankName      String
  accountNumber String
  routingNumber String
  iban          String?
  swiftCode     String?
   accountHolderName String
  user          User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}