generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                         String                  @id @default(cuid())
  name                       String?
  email                      String?                 @unique
  emailVerified              DateTime?
  image                      String?
  password                   String?
  role                       UserRole                @default(USER)
  isTwoFactorEnabled         Boolean                 @default(false)
  btc                        Float                   @default(0)
  eth                        Float                   @default(0)
  usdt                       Float                   @default(0)
  username                   String?                 @unique
  accounts                   Account[]
  accountDetails             AccountDetails?
  cardData                   CardData?
  cryptoSellTransactions     CryptoSellTransaction[]
  dashboardData              DashboardData?
  flights                    Flight[]
  giftCardWithdrawals        GiftCardWithdrawal[]
  receivedCryptoTransactions ReceivedTransaction[]   @relation("ReceivedCryptoTransactions")
  receivedTransactions       Transaction[]           @relation("ReceivedTransactions")
  transactions               Transaction[]           @relation("UserTransactions")
  twoFactorConfirmation      TwoFactorConfirmation?
  bankAccount                UserBankAccount?
  wireTransfers              WireTransfer[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model VerificationToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorConfirmation {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Transaction {
  id            Int      @id @default(autoincrement())
  date          DateTime
  amount        Float
  userId        String
  btc           Boolean  @default(false)
  eth           Boolean  @default(false)
  transactionId String   @unique @default(cuid())
  usdt          Boolean  @default(false)
  walletAddress String
  status        String   @default("pending")
  recipientId   String?
  recipient     User?    @relation("ReceivedTransactions", fields: [recipientId], references: [id], map: "recipient_transactions_fkey")
  user          User     @relation("UserTransactions", fields: [userId], references: [id], map: "user_transactions_fkey")

  @@index([userId])
  @@index([recipientId])
}

model ReceivedTransaction {
  id              String   @id @default(cuid())
  date            DateTime @default(now())
  amount          Float
  cryptoType      String
  senderAddress   String
  recipientId     String
  senderUsername  String
  status          String   @default("pending")
  transactionHash String   @unique
  recipient       User     @relation("ReceivedCryptoTransactions", fields: [recipientId], references: [id])
}

model BankAccount {
  id            String @id @default(cuid())
  bankName      String
  accountName   String
  accountNumber String
  status        String @default("active")
}

model UserBankAccount {
  id                     String                  @id @default(cuid())
  userId                 String                  @unique
  bankName               String
  accountNumber          String
  routingNumber          String
  iban                   String?
  swiftCode              String?
  accountHolderName      String
  cryptoSellTransactions CryptoSellTransaction[]
  user                   User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model CryptoSellTransaction {
  id              String          @id @default(cuid())
  userId          String
  bankAccountId   String
  currency        String
  amount          Float
  status          String          @default("pending")
  paid            Boolean         @default(false)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  userBankAccount UserBankAccount @relation(fields: [bankAccountId], references: [id])
  user            User            @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([bankAccountId])
}

model GiftCardWithdrawal {
  id           String   @id @default(cuid())
  userId       String
  giftCardName String
  amount       Float
  cryptoType   String
  status       String   @default("pending")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id])

  @@index([userId])
}

model DashboardData {
  id               String   @id @default(cuid())
  userId           String   @unique
  totalBalance     Float
  loanBalance      Float
  wireTransfer     Float
  domesticTransfer Float
  lastUpdated      DateTime @default(now())
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model CardData {
  id         String @id @default(cuid())
  userId     String @unique
  cardNumber String
  cardHolder String
  expiryDate String
  cvv        String
  cardLimit  Float
  user       User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model AccountDetails {
  id                   String   @id @default(cuid())
  userId               String   @unique
  accountNumber        String
  currency             String
  accountType          String
  status               String
  accountLimit         Float
  transactionCount     Int      @default(0)
  lastTransactionReset DateTime @default(now())
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model WireTransfer {
  id                  String   @id @default(cuid())
  userId              String
  destinationCurrency String
  bankName            String
  accountName         String
  accountNumber       String
  accountCountry      String
  swiftCode           String
  routingNumber       String
  accountType         String
  amount              Float
  remarks             String?
  status              String   @default("pending")
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  user                User     @relation(fields: [userId], references: [id])

  @@index([userId])
}

model PaymentMethod {
  id            String            @id @default(cuid())
  name          String
  type          PaymentMethodType
  instructions  String
  accountInfo   String?
  walletAddress String?
  isActive      Boolean           @default(true)
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  bookings      FlightBooking[]
}

model Flight {
  id                   String          @id @default(cuid())
  fromCity            String
  toCity              String
  departureDate       DateTime
  returnDate          DateTime?
  price               Float
  availableSeats      Int
  flightNumber        String
  airline             String
  minPrice            Float?
  maxPrice            Float?
  minSeats            Int?
  maxSeats            Int?
  hoursBetween        Int?
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
  userId              String
  baseFlightId        String?
  status              String?         @default("On Time")
  departureTerminal   String?
  arrivalTerminal     String?
  departureGate       String?
  arrivalGate         String?
  baggageClaim        String?
  actualDepartureTime DateTime?
  estimatedArrivalTime DateTime?
  scheduledDepartureTime DateTime?
  scheduledArrivalTime DateTime?
  aircraftModel       String?
  aircraftType        String?
  baseFlight          Flight?         @relation("FlightVariations", fields: [baseFlightId], references: [id])
  variations          Flight[]        @relation("FlightVariations")
  user                User            @relation(fields: [userId], references: [id])
  bookings            FlightBooking[]

  @@index([userId])
  @@index([baseFlightId])
}

model FlightBooking {
  id                 String        @id @default(cuid())
  ticketNumber       String        @unique @default(dbgenerated("('TKT'::text || lpad((floor((random() * (100000)::double precision)))::text, 6, '0'::text))"))
  flightId           String
  paymentMethodId    String
  amount             Float
  passengerName      String
  email              String
  status             String        @default("PENDING")
  paymentConfirmedAt DateTime?
  approvedAt         DateTime?
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  flight             Flight        @relation(fields: [flightId], references: [id])
  paymentMethod      PaymentMethod @relation(fields: [paymentMethodId], references: [id])

  @@index([flightId])
  @@index([paymentMethodId])
}

enum UserRole {
  ADMIN
  USER
}

enum PaymentMethodType {
  CRYPTO
  FIAT
}
